//@version=6

// -----------------------------------------------------------------------------
//
// This script is an enhanced trading framework that builds upon the foundational 
// neural network signal grading engine from the "Trend Architect Lite" indicator.
//
// Original Concept & Neural Network Engine By:
// The author/source of "Trend Architect Lite" (Credit where it's due).
//
// My Contributions:
// - Developed a comprehensive Moving Average filtering system (Directional, Z-Score Distance, Contact).
// - Integrated a multi-timeframe secondary Moving Average for trend confirmation.
// - Engineered a full trading session filter (Sydney, Tokyo, London, NY) with DST handling and visual boxes.
// - Refined the UI/UX with advanced color customization and a streamlined alert system.
//
// -----------------------------------------------------------------------------

indicator("Neural Network Buy and Sell Signals", shorttitle="NeuralNet", overlay=true, max_labels_count=500)


var string scalpHelperGroup = "Scalp Helper Signal Settings"
enable_scalp_helper = input.bool(true, "Enable Scalp Helper Signals", group=scalpHelperGroup)
signalCandleType = input.string("Candlesticks", "Signal Candle Type", options=["Candlesticks", "Heikin Ashi", "Linear Regression"], group=scalpHelperGroup)


signal_trigger_mult = input.float(3.0, "Signal Trigger Sensitivity", minval=0.1, maxval=10.0, step=0.1, group=scalpHelperGroup)
stop_atr_mult = input.float(1.5, "Stop Loss ATR Multiplier", minval=0.1, maxval=10.0, step=0.1, group=scalpHelperGroup)


// MOVING AVERAGE FILTER SETTINGS
var string maFilterGroup = "Moving Average Filter Settings"
ma_directional_filter = input.string("Both", "MA Directional Filter", options=["Both", "Trend Following", "Counter Trend"], group=maFilterGroup, tooltip="Both: Shows both trend and counter trend signals with distance filters | Trend Following: Buy above MA, Sell below MA | Counter Trend: Buy below MA, Sell above MA")

enable_trend_distance_filter = input.bool(false, "Enable Trend Following Distance Filter", group=maFilterGroup, tooltip="When enabled, excludes trend following signals when price is more than Z-score standard deviations from MA")
trend_distance_zscore = input.float(1.0, "Trend Distance Z-Score", minval=0.1, maxval=5.0, step=0.1, group=maFilterGroup, tooltip="Z-score threshold for trend following signals - higher values allow signals further from MA")

enable_counter_distance_filter = input.bool(false, "Enable Counter Trend Distance Filter", group=maFilterGroup, tooltip="When enabled, excludes counter trend signals when price is less than Z-score standard deviations from MA") 
counter_distance_zscore = input.float(1.0, "Counter Trend Distance Z-Score", minval=0.1, maxval=5.0, step=0.1, group=maFilterGroup, tooltip="Z-score threshold for counter trend signals - higher values require signals further from MA")

enable_ma_contact_filter = input.bool(false, "Enable MA Contact Filter", group=maFilterGroup, tooltip="When enabled, excludes signals when price candles are in contact with the MA")
ma_contact_type = input.string("Either", "MA Contact Type", options=["Wick", "Body", "Either"], group=maFilterGroup, tooltip="Wick: Only wick contact | Body: Only body contact | Either: Any contact with MA")

// MOVING AVERAGE SETTINGS
var string movingAverageGroup = "Moving Average Settings"
ma_length = input.int(50, "MA Length", minval=1, maxval=200, group=movingAverageGroup, tooltip="Main moving average length")
ma_type = input.string("KAMA", "MA Type", options=["SMA", "EMA", "WMA", "VWMA", "RMA", "HMA", "ALMA", "TEMA", "KAMA"], group=movingAverageGroup, tooltip="Main moving average type")

// ALMA specific settings
alma_offset = input.float(0.85, "ALMA Offset", minval=0.0, maxval=1.0, step=0.01, group=movingAverageGroup, tooltip="ALMA offset parameter (only used when ALMA is selected)")
alma_sigma = input.float(6.0, "ALMA Sigma", minval=0.1, maxval=10.0, step=0.1, group=movingAverageGroup, tooltip="ALMA sigma parameter (only used when ALMA is selected)")

// KAMA specific settings  
kama_fast_length = input.int(2, "KAMA Fast Length", minval=1, maxval=50, group=movingAverageGroup, tooltip="KAMA fast smoothing constant (only used when KAMA is selected)")
kama_slow_length = input.int(30, "KAMA Slow Length", minval=1, maxval=100, group=movingAverageGroup, tooltip="KAMA slow smoothing constant (only used when KAMA is selected)")

// SECONDARY MOVING AVERAGE SETTINGS
var string secondaryMAGroup = "Secondary Moving Average Settings"
enable_secondary_ma = input.bool(true, "Show Secondary MA", group=secondaryMAGroup, tooltip="Enable/disable the secondary red moving average")
secondary_ma_timeframe = input.string("Current", "Secondary MA Timeframe", options=["Current", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "4h"], group=secondaryMAGroup, tooltip="Timeframe for the secondary moving average calculation")
secondary_ma_length = input.int(50, "Secondary MA Length", minval=1, maxval=200, group=secondaryMAGroup, tooltip="Secondary moving average length")
secondary_ma_type = input.string("SMA", "Secondary MA Type", options=["SMA", "EMA", "WMA", "VWMA", "RMA", "HMA", "ALMA", "TEMA", "KAMA"], group=secondaryMAGroup, tooltip="Secondary moving average type")

// Secondary ALMA specific settings
secondary_alma_offset = input.float(0.85, "Secondary ALMA Offset", minval=0.0, maxval=1.0, step=0.01, group=secondaryMAGroup, tooltip="Secondary ALMA offset parameter (only used when ALMA is selected)")
secondary_alma_sigma = input.float(6.0, "Secondary ALMA Sigma", minval=0.1, maxval=10.0, step=0.1, group=secondaryMAGroup, tooltip="Secondary ALMA sigma parameter (only used when ALMA is selected)")

// Secondary KAMA specific settings  
secondary_kama_fast_length = input.int(2, "Secondary KAMA Fast Length", minval=1, maxval=50, group=secondaryMAGroup, tooltip="Secondary KAMA fast smoothing constant (only used when KAMA is selected)")
secondary_kama_slow_length = input.int(30, "Secondary KAMA Slow Length", minval=1, maxval=100, group=secondaryMAGroup, tooltip="Secondary KAMA slow smoothing constant (only used when KAMA is selected)")


// TRADING SESSIONS
var string sessionsGroup = "Trading Sessions"
show_sessions = input.bool(true, "Show Trading Sessions", group=sessionsGroup)
sydney_dst = input.bool(false, "Sydney DST", group=sessionsGroup, tooltip="Sydney DST (AEDT): Oct 5, 2025 - Apr 5, 2026 | Standard: 6 AM to 3 PM SGT | DST: 5 AM to 2 PM SGT")
london_dst = input.bool(true, "London DST", group=sessionsGroup, tooltip="London DST (BST): Mar 30 - Oct 26, 2025 | Standard: 4 PM to 1 AM SGT | DST: 3 PM to 12 AM SGT")
newyork_dst = input.bool(true, "New York DST", group=sessionsGroup, tooltip="New York DST (EDT): Mar 9 - Nov 2, 2025 | Standard: 9 PM to 6 AM SGT | DST: 8 PM to 5 AM SGT")


var string sessionSignalsGroup = "Session Signal Controls"
enable_sydney_signals = input.bool(true, "Sydney Session Signals", group=sessionSignalsGroup, tooltip="Enable/Disable buy/sell signals during Sydney session. When disabled, no signals will appear during Sydney trading hours regardless of other conditions.")
enable_tokyo_signals = input.bool(true, "Tokyo Session Signals", group=sessionSignalsGroup, tooltip="Enable/Disable buy/sell signals during Tokyo session. When disabled, no signals will appear during Tokyo trading hours regardless of other conditions.")
enable_london_signals = input.bool(true, "London Session Signals", group=sessionSignalsGroup, tooltip="Enable/Disable buy/sell signals during London session. When disabled, no signals will appear during London trading hours regardless of other conditions.")
enable_newyork_signals = input.bool(true, "New York Session Signals", group=sessionSignalsGroup, tooltip="Enable/Disable buy/sell signals during New York session. When disabled, no signals will appear during New York trading hours regardless of other conditions.")
enable_sydney_tokyo_overlap = input.bool(true, "Sydney-Tokyo Overlap Signals", group=sessionSignalsGroup, tooltip="Enable/Disable signals during Sydney-Tokyo overlap period. When enabled, signals will show during overlap even if individual sessions are disabled. When disabled, follows individual session settings.")
enable_london_newyork_overlap = input.bool(true, "London-New York Overlap Signals", group=sessionSignalsGroup, tooltip="Enable/Disable signals during London-New York overlap period. When enabled, signals will show during overlap even if individual sessions are disabled. When disabled, follows individual session settings.")


var string qualityGroup = "Quality of Signals Shown"
show_grade_a_plus = input.bool(true, "Show A+ Signals", group=qualityGroup)
show_grade_a = input.bool(true, "Show A Signals", group=qualityGroup)
show_grade_b = input.bool(true, "Show B Signals", group=qualityGroup)
show_grade_c = input.bool(true, "Show C Signals", group=qualityGroup)
show_grade_d = input.bool(true, "Show D Signals", group=qualityGroup)
show_grade_f = input.bool(true, "Show F Signals", group=qualityGroup)


var string candleGroup = "Candlestick Settings"
candleType = input.string("Candlesticks", "Candle Type", options=["Candlesticks", "Heikin Ashi", "Linear Regression"], group=candleGroup)
lrcLength = input.int(6, "Linear Regression Length", minval=1, group=candleGroup)


var string visualGroup = "Display Settings"
signalOffset = input.float(3.0, "Signal Distance from Candles", minval=0.1, maxval=3.0, step=0.1, group=visualGroup)
signalLabelSize = input.string("small", "Signal Label Size", options=["tiny", "small", "medium", "large"], group=visualGroup)


// Signal Color Controls
use_custom_colors = input.bool(false, "Use Custom Signal Colors", group=visualGroup, tooltip="Enable to customize individual signal grade colors")
colorStyle = input.string("Light", "Signal Color Style", options=["Light", "Medium", "Dark"], group=visualGroup, tooltip="Light: Bright vibrant colors | Medium: Balanced colors | Dark: Deeper colors")


// Custom color inputs
custom_a_plus_color = input.color(color.new(#55EE55, 0), "A+ Signal Color", group=visualGroup)
custom_a_color = input.color(color.new(#99EE55, 0), "A Signal Color", group=visualGroup)
custom_b_color = input.color(color.new(#DDEE55, 0), "B Signal Color", group=visualGroup)
custom_c_color = input.color(color.new(#EEDD55, 0), "C Signal Color", group=visualGroup)
custom_d_color = input.color(color.new(#EE9955, 0), "D Signal Color", group=visualGroup)
custom_f_color = input.color(color.new(#EE5555, 0), "F Signal Color", group=visualGroup)


// MANUAL SESSION TIME CONTROLS - AT BOTTOM
var string manualTimesGroup = "Manual Session Times (SGT)"
use_manual_times = input.bool(false, "Use Manual Session Times", group=manualTimesGroup, tooltip="Override automatic DST calculations with manual time settings. When enabled, you can set custom session times in SGT (UTC+8).")


manual_sydney_time = input.session("0600-1500", "Sydney Session Time", group=manualTimesGroup, tooltip="Sydney session time in SGT format (HHMM-HHMM). Default: 0600-1500 for standard time, 0500-1400 for DST.")


manual_tokyo_time = input.session("0800-1700", "Tokyo Session Time", group=manualTimesGroup, tooltip="Tokyo session time in SGT format (HHMM-HHMM). Default: 0800-1700 (no DST).")


manual_london_time = input.session("1500-0000", "London Session Time", group=manualTimesGroup, tooltip="London session time in SGT format (HHMM-HHMM). Default: 1500-0000 for DST, 1600-0100 for standard time.")


manual_newyork_time = input.session("2000-0500", "New York Session Time", group=manualTimesGroup, tooltip="New York session time in SGT format (HHMM-HHMM). Default: 2000-0500 for DST, 2100-0600 for standard time.")


// COMPREHENSIVE MOVING AVERAGE FUNCTION WITH TIMEFRAME SUPPORT
f_movingAverage(src, length, ma_type_param, alma_offset_param, alma_sigma_param, kama_fast_param, kama_slow_param) =>
    switch ma_type_param
        "SMA" => ta.sma(src, length)
        "EMA" => ta.ema(src, length)
        "WMA" => ta.wma(src, length)
        "VWMA" => ta.vwma(src, length)
        "RMA" => ta.rma(src, length)
        "HMA" => ta.hma(src, length)
        "ALMA" => ta.alma(src, length, alma_offset_param, alma_sigma_param)
        "TEMA" => 
            ema1 = ta.ema(src, length)
            ema2 = ta.ema(ema1, length)
            ema3 = ta.ema(ema2, length)
            3 * ema1 - 3 * ema2 + ema3
        "KAMA" =>
            change = math.abs(src - src[length])
            volatility = 0.0
            for i = 0 to length - 1
                volatility += math.abs(src[i] - src[i + 1])
            efficiency_ratio = volatility != 0 ? change / volatility : 0
            fast_sc = 2.0 / (kama_fast_param + 1)
            slow_sc = 2.0 / (kama_slow_param + 1)
            smooth_const = math.pow(efficiency_ratio * (fast_sc - slow_sc) + slow_sc, 2)
            var float kama_val = src
            kama_val := nz(kama_val[1]) + smooth_const * (src - nz(kama_val[1]))
            kama_val
        => ta.ema(src, length) // Default fallback

// FUNCTION TO GET TIMEFRAME STRING
f_getTimeframe(tf_input) =>
    switch tf_input
        "Current" => timeframe.period
        "1m" => "1"
        "2m" => "2"
        "3m" => "3"
        "5m" => "5"
        "15m" => "15"
        "30m" => "30"
        "1h" => "60"
        "4h" => "240"
        => timeframe.period


buy_signal_length = 2
buy_atr_length = 18
sell_signal_length = 2
sell_atr_length = 18
buy_signal_use_close = false
buy_atr_use_close = true
sell_signal_use_close = false
sell_atr_use_close = true


amf_length = 14
amf_signal_length = 9
amf_smoothing = 3
amf_fast_length = 5
amf_slow_length = 21
amf_far_threshold = 0.3
amf_slope_fast_threshold = 0.03


h1_amf_weight = 1.2
h1_alma_weight = 0.4
h1_sr_weight = 0.5
h1_swing_weight = 0.4
h1_regime_weight = 0.7
h1_bias = 0.2


h2_amf_weight = 1.4
h2_alma_weight = 0.3
h2_sr_weight = 0.6
h2_swing_weight = 0.3
h2_regime_weight = 0.8
h2_bias = 0.15


h3_amf_weight = 1.6
h3_alma_weight = 0.4
h3_sr_weight = 0.4
h3_swing_weight = 0.5
h3_regime_weight = 0.6
h3_bias = 0.25


out_h1_weight = 0.4
out_h2_weight = 0.4
out_h3_weight = 0.4
out_bias = 0.3


enable_input_normalization = true
normalization_lookback = 50
outlier_clipping = true
clipping_threshold = 3.0


almaLength = 20
almaOffset = 0.85
almaSigma = 6.0
alma2Length = 20
alma2Offset = 0.77
alma2Sigma = 6.0
alma_wide_gap_threshold = 0.1


pivot_lookback = 10
sr_proximity_threshold = 0.5
sr_breakout_threshold = 0.2
swing_structure_length = 20
regime_lookback = 30
trending_threshold = 0.6


showScalpLabels = true


var float signalOpen = open
var float signalHigh = high
var float signalLow = low
var float signalClose = close


customBuyColor = color.new(#00FFFF, 0)
customSellColor = color.new(#FF0000, 0)
textColor = color.new(color.white, 0)


//Get session range - FIXED FOR FULL HISTORICAL COVERAGE
get_range(session, session_name, session_css)=>
    var t = 0
    var max = high
    var min = low
    var box bx = na
    var label lbl = na
    
    in_session = session > 0
    session_start = in_session and (na(session[1]) or session[1] == 0)
    session_continue = in_session and session[1] > 0
    session_end = (na(session) or session == 0) and session[1] > 0
    
    // Session starts
    if session_start
        t := time
        max := high
        min := low
        
        if show_sessions
            bx := box.new(bar_index, max, bar_index, min
              , bgcolor = color.new(session_css, 85)
              , border_color = session_css
              , border_style = line.style_dotted
              , extend = extend.none)
            
            lbl := label.new(bar_index, max, session_name
              , xloc = xloc.bar_index
              , textcolor = session_css
              , style = label.style_label_down
              , color = color.new(color.white, 100)
              , size = size.tiny)
    
    // Session continues - extend the box
    if session_continue
        max := math.max(high, max)
        min := math.min(low, min)
        
        if show_sessions and not na(bx)
            box.set_top(bx, max)
            box.set_bottom(bx, min)
            box.set_right(bx, bar_index)
            
            if not na(lbl)
                label.set_x(lbl, bar_index)
                label.set_y(lbl, max)
    
    // Session ends - finalize the box
    if session_end and show_sessions and not na(bx)
        box.set_right(bx, bar_index - 1)
        
    [bx, lbl]


f_ema_amf(source, len) =>
    var float ema_val = na
    float alpha = 2.0 / (len + 1)
    if not na(source) and len > 0
        ema_val := alpha * source + (1 - alpha) * nz(ema_val[1])
    ema_val


f_dema_amf(source, len) =>
    float ema1 = f_ema_amf(source, len)
    float ema2 = f_ema_amf(ema1, len)
    2 * ema1 - ema2


f_zlema_amf(source, len) =>
    int lag = int((len - 1) / 2)
    float lag_source = lag > 0 ? source[lag] : source
    float adjusted_source = source + (source - lag_source)
    f_ema_amf(adjusted_source, len)


f_sum_amf(source, len) =>
    float sum_val = 0.0
    for i = 0 to len - 1
        sum_val += nz(source[i], 0)
    sum_val


f_calculate_amf(src, length, fast_len, slow_len, smooth_len) =>
    float current_atr = ta.atr(14)
    float avg_atr = ta.sma(current_atr, 50)
    float volatility_ratio = avg_atr > 0 ? current_atr / avg_atr : 1.0
   
    float volatility_sensitivity = 2.0
    float raw_adaptive_lookback = float(length) / math.pow(volatility_ratio, volatility_sensitivity)
    int adaptive_lookback = int(math.max(5, math.min(50, raw_adaptive_lookback)))
   
    if adaptive_lookback < 1
        adaptive_lookback := 1


    int zlema_fast_len = adaptive_lookback
    int dema_medium_len = int(adaptive_lookback * 1.5)
    int dema_slow_len = int(adaptive_lookback * 2.5)
   
    if dema_medium_len < 1
        dema_medium_len := 1
    if dema_slow_len < 1
        dema_slow_len := 1


    float zlema_fast = f_zlema_amf(src, zlema_fast_len)
    float dema_medium = f_dema_amf(src, dema_medium_len)
    float dema_slow = f_dema_amf(src, dema_slow_len)


    float pv = 0.0
    if src > src[1]
        pv := volume
    else if src < src[1]
        pv := -volume


    float vzo_sum = f_sum_amf(pv, length)
    float vol_sum = f_sum_amf(volume, length)
    float vzo_value = vol_sum != 0 ? 100 * (vzo_sum / vol_sum) : 0.0
    float smoothed_vzo = ta.sma(vzo_value, 3)


    float price_vs_fast_weight = 30.0
    float fast_vs_medium_weight = 30.0
    float medium_vs_slow_weight = 40.0
    float vzo_weight = 20.0


    float oscillator_score = 0.0


    if src > zlema_fast
        oscillator_score += price_vs_fast_weight
    else if src < zlema_fast
        oscillator_score -= price_vs_fast_weight


    if zlema_fast > dema_medium
        oscillator_score += fast_vs_medium_weight
    else if zlema_fast < dema_medium
        oscillator_score -= fast_vs_medium_weight


    if dema_medium > dema_slow
        oscillator_score += medium_vs_slow_weight
    else if dema_medium < dema_slow
        oscillator_score -= medium_vs_slow_weight


    oscillator_score += (smoothed_vzo / 100) * vzo_weight


    float max_possible_score = price_vs_fast_weight + fast_vs_medium_weight + medium_vs_slow_weight + vzo_weight
    float normalized_score = max_possible_score != 0.0 ? (oscillator_score / max_possible_score) * 100.0 : 0.0
    ta.ema(normalized_score / 100.0, smooth_len)


f_amf_signal(amf_line, signal_length) =>
    ta.ema(amf_line, signal_length)


cached_atr = ta.atr(14)


f_normalizeInput(value, lookback_period, enable_clipping, clip_threshold) =>
    if not enable_input_normalization
        value
    else
        mean_val = ta.sma(value, lookback_period)
        variance = ta.sma(math.pow(value - mean_val, 2), lookback_period)
        std_val = math.sqrt(variance)
        normalized = std_val > 0 ? (value - mean_val) / std_val : 0.0
        if enable_clipping
            math.max(-clip_threshold, math.min(clip_threshold, normalized))
        else
            normalized


f_tanh(x) =>
    ex = math.exp(2 * x)
    (ex - 1) / (ex + 1)


f_scoreSignalNormalized(amf_norm, alma_norm, sr_norm, swing_norm, regime_norm) =>
    input_scale = 0.8
    scaled_amf = amf_norm * input_scale
    scaled_alma = alma_norm * input_scale
    scaled_sr = sr_norm * input_scale
    scaled_swing = swing_norm * input_scale
    scaled_regime = regime_norm * input_scale
   
    hidden1 = f_tanh(h1_amf_weight*scaled_amf + h1_alma_weight*scaled_alma + h1_sr_weight*scaled_sr + h1_swing_weight*scaled_swing + h1_regime_weight*scaled_regime + h1_bias)
    hidden2 = f_tanh(h2_amf_weight*scaled_amf + h2_alma_weight*scaled_alma + h2_sr_weight*scaled_sr + h2_swing_weight*scaled_swing + h2_regime_weight*scaled_regime + h2_bias)
    hidden3 = f_tanh(h3_amf_weight*scaled_amf + h3_alma_weight*scaled_alma + h3_sr_weight*scaled_sr + h3_swing_weight*scaled_swing + h3_regime_weight*scaled_regime + h3_bias)
   
    raw_output = out_h1_weight*hidden1 + out_h2_weight*hidden2 + out_h3_weight*hidden3 + out_bias
    temperature = 1.2
    1.0 / (1.0 + math.exp(-raw_output / temperature))


f_getSignalGrade(score) =>
    if score >= 0.80
        "A+"  
    else if score >= 0.76
        "A"  
    else if score >= 0.65
        "B"  
    else if score >= 0.40
        "C"  
    else if score >= 0.32
        "D"  
    else
        "F"


f_getScoreColor(score) =>
    if use_custom_colors
        if score >= 0.80
            custom_a_plus_color  // A+ - Custom Color
        else if score >= 0.76
            custom_a_color       // A - Custom Color
        else if score >= 0.65
            custom_b_color       // B - Custom Color
        else if score >= 0.40
            custom_c_color       // C - Custom Color
        else if score >= 0.32
            custom_d_color       // D - Custom Color
        else
            custom_f_color       // F - Custom Color
    else if colorStyle == "Light"
        if score >= 0.80
            color.new(#55EE55, 0)  // A+ - Lighter Green
        else if score >= 0.76
            color.new(#99EE55, 0)  // A - Lighter Green-Yellow
        else if score >= 0.65
            color.new(#DDEE55, 0)  // B - Lighter Yellow-Green
        else if score >= 0.40
            color.new(#EEDD55, 0)  // C - Lighter Yellow-Orange
        else if score >= 0.32
            color.new(#EE9955, 0)  // D - Lighter Orange-Red
        else
            color.new(#EE5555, 0)  // F - Lighter Red
    else if colorStyle == "Medium"
        if score >= 0.80
            color.new(#33DD33, 0)  // A+ - Medium Green
        else if score >= 0.76
            color.new(#88DD33, 0)  // A - Medium Green-Yellow
        else if score >= 0.65
            color.new(#CCDD33, 0)  // B - Medium Yellow-Green
        else if score >= 0.40
            color.new(#DDCC33, 0)  // C - Medium Yellow-Orange
        else if score >= 0.32
            color.new(#DD8833, 0)  // D - Medium Orange-Red
        else
            color.new(#DD3333, 0)  // F - Medium Red
    else // "Dark"
        if score >= 0.80
            color.new(#00AA00, 0)  // A+ - Dark Green
        else if score >= 0.76
            color.new(#66BB00, 0)  // A - Dark Green-Yellow
        else if score >= 0.65
            color.new(#AACC00, 0)  // B - Dark Yellow-Green
        else if score >= 0.40
            color.new(#CCAA00, 0)  // C - Dark Yellow-Orange
        else if score >= 0.32
            color.new(#CC6600, 0)  // D - Dark Orange-Red
        else
            color.new(#AA0000, 0)  // F - Dark Red


f_analyzeAMF(amf_line, signal_line, is_buy, is_sell, cached_atr) =>
    amf_vs_signal = amf_line - signal_line
    crossing_up = amf_line > signal_line and amf_line[1] <= signal_line[1]
    crossing_down = amf_line < signal_line and amf_line[1] >= signal_line[1]
    normalized_distance = math.abs(amf_vs_signal) / cached_atr
    is_far = normalized_distance > amf_far_threshold
    signal_slope = (signal_line - signal_line[1]) / cached_atr
    slope_fast_falling = signal_slope < -amf_slope_fast_threshold
    slope_fast_rising = signal_slope > amf_slope_fast_threshold
    var float amf_score = 0.0
    if is_buy
        if crossing_up or amf_line > signal_line
            amf_score := 1.0  
        else if amf_line < signal_line
            if is_far
                amf_score := -0.8
            else
                amf_score := -0.4
        else
            amf_score := 0.0
        if slope_fast_falling
            amf_score := amf_score - 0.3
    else if is_sell
        if crossing_down or amf_line < signal_line
            amf_score := 1.0  
        else if amf_line > signal_line
            if is_far
                amf_score := -0.8
            else
                amf_score := -0.4
        else
            amf_score := 0.0
        if slope_fast_rising
            amf_score := amf_score - 0.3
    else
        amf_score := 0.0
    math.max(-1.0, math.min(1.0, amf_score))


f_analyzeALMA(fast_alma, slow_alma, is_buy, is_sell, cached_atr) =>
    alma_gap = fast_alma - slow_alma
    normalized_gap = math.abs(alma_gap) / cached_atr
    is_wide_gap = normalized_gap > alma_wide_gap_threshold
    crossing_up = fast_alma > slow_alma and fast_alma[1] <= slow_alma[1]
    crossing_down = fast_alma < slow_alma and fast_alma[1] >= slow_alma[1]
    var float alma_score = 0.0
    if is_buy
        if crossing_up or fast_alma > slow_alma
            alma_score := 0.5
        else if fast_alma < slow_alma
            if is_wide_gap
                alma_score := -0.8
            else
                alma_score := -0.2
        else
            alma_score := 0.0
    else if is_sell
        if crossing_down or fast_alma < slow_alma
            alma_score := 0.5
        else if fast_alma > slow_alma
            if is_wide_gap
                alma_score := -0.8
            else
                alma_score := -0.2
        else
            alma_score := 0.0
    else
        alma_score := 0.0
    alma_score


f_analyzeSupportResistance(is_buy, is_sell, cached_atr, sig_high, sig_low, sig_close) =>
    pivot_high = ta.pivothigh(sig_high, pivot_lookback, pivot_lookback)
    pivot_low = ta.pivotlow(sig_low, pivot_lookback, pivot_lookback)
    var float nearest_resistance = na
    var float nearest_support = na
    if not na(pivot_high)
        nearest_resistance := pivot_high
    if not na(pivot_low)
        nearest_support := pivot_low
    resistance_distance = nearest_resistance > 0 ? math.abs(sig_close - nearest_resistance) / cached_atr : 999
    support_distance = nearest_support > 0 ? math.abs(sig_close - nearest_support) / cached_atr : 999
    near_resistance = resistance_distance <= sr_proximity_threshold
    near_support = support_distance <= sr_proximity_threshold
    recent_resistance_break = nearest_resistance > 0 and sig_close > nearest_resistance and sig_close[5] <= nearest_resistance
    recent_support_break = nearest_support > 0 and sig_close < nearest_support and sig_close[5] >= nearest_support
    var float sr_score = 0.0
    if is_buy
        if recent_resistance_break
            sr_score := 0.8
        else if near_support
            sr_score := 0.5
        else if near_resistance
            sr_score := -0.6
        else
            sr_score := 0.0
    else if is_sell
        if recent_support_break
            sr_score := 0.8
        else if near_resistance
            sr_score := 0.5
        else if near_support
            sr_score := -0.6
        else
            sr_score := 0.0
    else
        sr_score := 0.0
    sr_score


f_analyzeSwingStructure(is_buy, is_sell, sig_high, sig_low) =>
    recent_high = ta.highest(sig_high, swing_structure_length)
    recent_low = ta.lowest(sig_low, swing_structure_length)
    previous_high = ta.highest(sig_high[swing_structure_length], swing_structure_length)
    previous_low = ta.lowest(sig_low[swing_structure_length], swing_structure_length)
    making_higher_highs = recent_high > previous_high
    making_higher_lows = recent_low > previous_low
    making_lower_highs = recent_high < previous_high
    making_lower_lows = recent_low < previous_low
    bullish_structure = making_higher_highs and making_higher_lows
    bearish_structure = making_lower_highs and making_lower_lows
    var float swing_score = 0.0
    if is_buy
        if bullish_structure
            swing_score := 0.6
        else if bearish_structure
            swing_score := -0.7
        else
            swing_score := -0.1
    else if is_sell
        if bearish_structure
            swing_score := 0.6
        else if bullish_structure
            swing_score := -0.7
        else
            swing_score := -0.1
    else
        swing_score := 0.0
    swing_score


f_analyzeMarketRegime(is_buy, is_sell, sig_open, sig_high, sig_low, sig_close) =>
    tr1 = math.max(sig_high - sig_low, math.abs(sig_high - sig_close[1]))
    tr = math.max(tr1, math.abs(sig_low - sig_close[1]))
    plus_dm = sig_high - sig_high[1] > sig_low[1] - sig_low ? math.max(sig_high - sig_high[1], 0) : 0
    minus_dm = sig_low[1] - sig_low > sig_high - sig_high[1] ? math.max(sig_low[1] - sig_low, 0) : 0
    plus_di = 100 * ta.rma(plus_dm, regime_lookback) / ta.rma(tr, regime_lookback)
    minus_di = 100 * ta.rma(minus_dm, regime_lookback) / ta.rma(tr, regime_lookback)
    dx = math.abs(plus_di - minus_di) / (plus_di + minus_di) * 100
    adx = ta.rma(dx, regime_lookback)
    trending_market = adx >= trending_threshold * 100
    bullish_trend = trending_market and plus_di > minus_di
    bearish_trend = trending_market and minus_di > plus_di
    var float regime_score = 0.0
    if is_buy
        if bullish_trend
            regime_score := 0.7
        else if bearish_trend
            regime_score := -0.8
        else
            regime_score := -0.2
    else if is_sell
        if bearish_trend
            regime_score := 0.7
        else if bullish_trend
            regime_score := -0.8
        else
            regime_score := -0.2
    else
        regime_score := 0.0
    regime_score


calculateHA() =>
    var haOpen = 0.0
    var haHigh = 0.0
    var haLow = 0.0
    var haClose = 0.0
    newHaClose = (open + high + low + close) / 4
    newHaOpen = na(haOpen[1]) ? (open + close) / 2 : (haOpen[1] + haClose[1]) / 2
    newHaHigh = math.max(high, math.max(newHaOpen, newHaClose))
    newHaLow = math.min(low, math.min(newHaOpen, newHaClose))
    haClose := newHaClose
    haOpen := newHaOpen
    haHigh := newHaHigh
    haLow := newHaLow
    [newHaOpen, newHaHigh, newHaLow, newHaClose]


[oHA, hHA, lHA, cHA] = calculateHA()


var float displayOpen = na
var float displayHigh = na
var float displayLow = na
var float displayClose = na


if candleType == "Candlesticks"
    displayOpen := open
    displayHigh := high
    displayLow := low
    displayClose := close
else if candleType == "Heikin Ashi"
    displayOpen := oHA
    displayHigh := hHA
    displayLow := lHA
    displayClose := cHA
else if candleType == "Linear Regression"
    displayOpen := ta.linreg(open, lrcLength, 0)
    displayHigh := ta.linreg(high, lrcLength, 0)
    displayLow := ta.linreg(low, lrcLength, 0)
    displayClose := ta.linreg(close, lrcLength, 0)


isBullishCandle = displayClose > displayOpen


var float signalOpenCalc = na
var float signalHighCalc = na
var float signalLowCalc = na
var float signalCloseCalc = na


if signalCandleType == "Candlesticks"
    signalOpenCalc := open
    signalHighCalc := high
    signalLowCalc := low
    signalCloseCalc := close
else if signalCandleType == "Heikin Ashi"
    signalOpenCalc := oHA
    signalHighCalc := hHA
    signalLowCalc := lHA
    signalCloseCalc := cHA
else if signalCandleType == "Linear Regression"
    signalOpenCalc := ta.linreg(open, lrcLength, 0)
    signalHighCalc := ta.linreg(high, lrcLength, 0)
    signalLowCalc := ta.linreg(low, lrcLength, 0)
    signalCloseCalc := ta.linreg(close, lrcLength, 0)


signalOpen := signalOpenCalc
signalHigh := signalHighCalc
signalLow := signalLowCalc
signalClose := signalCloseCalc


// SESSIONS - ENHANCED DETECTION FOR FULL HISTORICAL COVERAGE
// Use manual times if enabled, otherwise use automatic DST calculation
sydney_session_time = use_manual_times ? manual_sydney_time : (sydney_dst ? "0500-1400" : "0600-1500")
tokyo_session_time = use_manual_times ? manual_tokyo_time : "0800-1700"
london_session_time = use_manual_times ? manual_london_time : (london_dst ? "1500-0000" : "1600-0100")
newyork_session_time = use_manual_times ? manual_newyork_time : (newyork_dst ? "2000-0500" : "2100-0600")

// Enhanced session detection with better historical coverage
sydney_session_raw = time(timeframe.period, sydney_session_time, "UTC+8")
tokyo_session_raw = time(timeframe.period, tokyo_session_time, "UTC+8")
london_session_raw = time(timeframe.period, london_session_time, "UTC+8")
newyork_session_raw = time(timeframe.period, newyork_session_time, "UTC+8")

// Convert to binary values with improved logic
sydney_session = not na(sydney_session_raw) ? 1.0 : 0.0
tokyo_session = not na(tokyo_session_raw) ? 1.0 : 0.0  
london_session = not na(london_session_raw) ? 1.0 : 0.0
newyork_session = not na(newyork_session_raw) ? 1.0 : 0.0


// Boolean versions for signal filtering
is_sydney = sydney_session > 0
is_tokyo = tokyo_session > 0
is_london = london_session > 0
is_newyork = newyork_session > 0


// SESSION OVERLAPS
is_sydney_tokyo_overlap = is_sydney and is_tokyo
is_london_newyork_overlap = is_london and is_newyork


// DRAW SESSIONS - FIXED FOR FULL HISTORICAL COVERAGE
if show_sessions
    [sydney_box, sydney_label] = get_range(sydney_session, "Sydney", color.new(#ffeb3b, 0))
    [tokyo_box, tokyo_label] = get_range(tokyo_session, "Tokyo", color.new(#e91e63, 0))
    [london_box, london_label] = get_range(london_session, "London", color.new(#2157f3, 0))
    [newyork_box, newyork_label] = get_range(newyork_session, "New York", color.new(#ff5d00, 0))


buy_signal_buySignal = false
sell_signal_sellSignal = false
buy_atr_sellSignal = false
sell_atr_buySignal = false
buy_atr_longStop = close
sell_atr_shortStop = close
var bool buy_atr_stop_active = false
var bool sell_atr_stop_active = false


if enable_scalp_helper
    buy_signal_atr = ta.atr(buy_signal_length) * signal_trigger_mult
    buy_signal_longStop = (buy_signal_use_close ? ta.highest(signalClose, buy_signal_length) : ta.highest(signalHigh, buy_signal_length)) - buy_signal_atr
    buy_signal_longStopPrev = nz(buy_signal_longStop[1], buy_signal_longStop)
    buy_signal_longStop := signalClose[1] > buy_signal_longStopPrev ? math.max(buy_signal_longStop, buy_signal_longStopPrev) : buy_signal_longStop
    buy_signal_shortStop = (buy_signal_use_close ? ta.lowest(signalClose, buy_signal_length) : ta.lowest(signalLow, buy_signal_length)) + buy_signal_atr
    buy_signal_shortStopPrev = nz(buy_signal_shortStop[1], buy_signal_shortStop)
    buy_signal_shortStop := signalClose[1] < buy_signal_shortStopPrev ? math.min(buy_signal_shortStop, buy_signal_shortStopPrev) : buy_signal_shortStop
    var int buy_signal_dir = 1
    buy_signal_dir := signalClose > buy_signal_shortStopPrev ? 1 : signalClose < buy_signal_longStopPrev ? -1 : buy_signal_dir
    buy_signal_buySignal := buy_signal_dir == 1 and buy_signal_dir[1] == -1
   
    buy_atr_atr = ta.atr(buy_atr_length) * stop_atr_mult
    buy_atr_longStop := (buy_atr_use_close ? ta.highest(signalClose, buy_atr_length) : ta.highest(signalHigh, buy_atr_length)) - buy_atr_atr
    buy_atr_longStopPrev = nz(buy_atr_longStop[1], buy_atr_longStop)
    buy_atr_longStop := signalClose[1] > buy_atr_longStopPrev ? math.max(buy_atr_longStop, buy_atr_longStopPrev) : buy_atr_longStop
    buy_atr_shortStop = (buy_atr_use_close ? ta.lowest(signalClose, buy_atr_length) : ta.lowest(signalLow, buy_atr_length)) + buy_atr_atr
    buy_atr_shortStopPrev = nz(buy_atr_shortStop[1], buy_atr_shortStop)
    buy_atr_shortStop := signalClose[1] < buy_atr_shortStopPrev ? math.min(buy_atr_shortStop, buy_atr_shortStopPrev) : buy_atr_shortStop
    var int buy_atr_dir = 1
    buy_atr_dir := signalClose > buy_atr_shortStopPrev ? 1 : signalClose < buy_atr_longStopPrev ? -1 : buy_atr_dir
    buy_atr_sellSignal := buy_atr_dir == -1 and buy_atr_dir[1] == 1
   
    sell_signal_atr = ta.atr(sell_signal_length) * signal_trigger_mult
    sell_signal_longStop = (sell_signal_use_close ? ta.highest(signalClose, sell_signal_length) : ta.highest(signalHigh, sell_signal_length)) - sell_signal_atr
    sell_signal_longStopPrev = nz(sell_signal_longStop[1], sell_signal_longStop)
    sell_signal_longStop := signalClose[1] > sell_signal_longStopPrev ? math.max(sell_signal_longStop, sell_signal_longStopPrev) : sell_signal_longStop
    sell_signal_shortStop = (sell_signal_use_close ? ta.lowest(signalClose, sell_signal_length) : ta.lowest(signalLow, sell_signal_length)) + sell_signal_atr
    sell_signal_shortStopPrev = nz(sell_signal_shortStop[1], sell_signal_shortStop)
    sell_signal_shortStop := signalClose[1] < sell_signal_shortStopPrev ? math.min(sell_signal_shortStop, sell_signal_shortStopPrev) : sell_signal_shortStop
    var int sell_signal_dir = 1
    sell_signal_dir := signalClose > sell_signal_shortStopPrev ? 1 : signalClose < sell_signal_longStopPrev ? -1 : sell_signal_dir
    sell_signal_sellSignal := sell_signal_dir == -1 and sell_signal_dir[1] == 1
   
    sell_atr_atr = ta.atr(sell_atr_length) * stop_atr_mult
    sell_atr_longStop = (sell_atr_use_close ? ta.highest(signalClose, sell_atr_length) : ta.highest(signalHigh, sell_atr_length)) - sell_atr_atr
    sell_atr_longStopPrev = nz(sell_atr_longStop[1], sell_atr_longStop)
    sell_atr_longStop := signalClose[1] > sell_atr_longStopPrev ? math.max(sell_atr_longStop, sell_atr_longStopPrev) : sell_atr_longStop
    sell_atr_shortStop := (sell_atr_use_close ? ta.lowest(signalClose, sell_atr_length) : ta.lowest(signalLow, sell_atr_length)) + sell_atr_atr
    sell_atr_shortStopPrev = nz(sell_atr_shortStop[1], sell_atr_shortStop)
    sell_atr_shortStop := signalClose[1] < sell_atr_shortStopPrev ? math.min(sell_atr_shortStop, sell_atr_shortStopPrev) : sell_atr_shortStop
    var int sell_atr_dir = 1
    sell_atr_dir := signalClose > sell_atr_shortStopPrev ? 1 : signalClose < sell_atr_longStopPrev ? -1 : sell_atr_dir
    sell_atr_buySignal := sell_atr_dir == 1 and sell_atr_dir[1] == -1
   
    if not buy_atr_stop_active
        if buy_signal_buySignal
            buy_atr_stop_active := true
    else
        if buy_atr_sellSignal
            buy_atr_stop_active := false


    if not sell_atr_stop_active
        if sell_signal_sellSignal
            sell_atr_stop_active := true
    else
        if sell_atr_buySignal
            sell_atr_stop_active := false


amf_line = f_calculate_amf(signalClose, amf_length, amf_fast_length, amf_slow_length, amf_smoothing)
amf_signal = f_amf_signal(amf_line, amf_signal_length)
atr14 = ta.atr(14)
alma200 = ta.alma(signalClose, almaLength, almaOffset, almaSigma)
alma2 = ta.alma(signalClose, alma2Length, alma2Offset, alma2Sigma)


// CALCULATE MOVING AVERAGES
flexible_ma = f_movingAverage(close, ma_length, ma_type, alma_offset, alma_sigma, kama_fast_length, kama_slow_length)

// CALCULATE SECONDARY MA WITH TIMEFRAME SUPPORT
secondary_tf = f_getTimeframe(secondary_ma_timeframe)
secondary_ma = if secondary_ma_timeframe == "Current"
    f_movingAverage(close, secondary_ma_length, secondary_ma_type, secondary_alma_offset, secondary_alma_sigma, secondary_kama_fast_length, secondary_kama_slow_length)
else
    request.security(syminfo.tickerid, secondary_tf, f_movingAverage(close, secondary_ma_length, secondary_ma_type, secondary_alma_offset, secondary_alma_sigma, secondary_kama_fast_length, secondary_kama_slow_length), lookahead=barmerge.lookahead_off)


// MA FILTER FUNCTIONS
f_maDirectionalFilter(is_buy_signal, is_sell_signal, current_close, ma_value, filter_type) =>
    if filter_type == "Both"
        true  // Allow both trend following and counter trend signals
    else if filter_type == "Trend Following"
        if is_buy_signal
            current_close > ma_value
        else if is_sell_signal
            current_close < ma_value
        else
            true
    else if filter_type == "Counter Trend"
        if is_buy_signal
            current_close < ma_value
        else if is_sell_signal
            current_close > ma_value
        else
            true
    else
        true

f_maContactFilter(candle_open, candle_close, candle_high, candle_low, ma_value, contact_type, is_enabled) =>
    if not is_enabled
        true
    else
        candle_body_high = math.max(candle_open, candle_close)
        candle_body_low = math.min(candle_open, candle_close)
        
        if contact_type == "Wick"
            // Check if wicks touch MA but body doesn't
            wick_contact = (candle_high >= ma_value and candle_low <= ma_value)
            body_contact = (candle_body_high >= ma_value and candle_body_low <= ma_value)
            not (wick_contact and not body_contact)
        else if contact_type == "Body"
            // Check if body touches MA
            not (candle_body_high >= ma_value and candle_body_low <= ma_value)
        else // "Either"
            // Check if any part of candle touches MA
            not (candle_high >= ma_value and candle_low <= ma_value)

f_maDistanceFilter(current_close, ma_value, directional_filter, is_buy_signal, is_sell_signal, trend_enabled, trend_zscore, counter_enabled, counter_zscore, lookback_periods) =>
    if directional_filter == "Both"
        // For "Both" mode, apply appropriate distance filter based on signal position relative to MA
        distance_sum = 0.0
        for i = 0 to lookback_periods - 1
            price_distance = math.abs(close[i] - ma_value[i])
            distance_sum += price_distance
        
        mean_distance = distance_sum / lookback_periods
        
        variance_sum = 0.0
        for i = 0 to lookback_periods - 1
            price_distance = math.abs(close[i] - ma_value[i])
            variance_sum += math.pow(price_distance - mean_distance, 2)
        
        std_dev = math.sqrt(variance_sum / lookback_periods)
        current_distance = math.abs(current_close - ma_value)
        z_score = std_dev > 0 ? current_distance / std_dev : 0
        
        // Determine if this is a trend following or counter trend signal
        is_trend_following = (is_buy_signal and current_close > ma_value) or (is_sell_signal and current_close < ma_value)
        is_counter_trend = (is_buy_signal and current_close < ma_value) or (is_sell_signal and current_close > ma_value)
        
        if is_trend_following and trend_enabled
            // Apply trend following filter: exclude signals MORE than z-score away from MA
            z_score <= trend_zscore
        else if is_counter_trend and counter_enabled
            // Apply counter trend filter: exclude signals LESS than z-score away from MA
            z_score >= counter_zscore
        else
            true
    else if directional_filter == "Trend Following"
        if trend_enabled
            // Calculate z-score and apply trend following filter
            distance_sum = 0.0
            for i = 0 to lookback_periods - 1
                price_distance = math.abs(close[i] - ma_value[i])
                distance_sum += price_distance
            
            mean_distance = distance_sum / lookback_periods
            
            variance_sum = 0.0
            for i = 0 to lookback_periods - 1
                price_distance = math.abs(close[i] - ma_value[i])
                variance_sum += math.pow(price_distance - mean_distance, 2)
            
            std_dev = math.sqrt(variance_sum / lookback_periods)
            current_distance = math.abs(current_close - ma_value)
            z_score = std_dev > 0 ? current_distance / std_dev : 0
            
            z_score <= trend_zscore
        else
            true
    else if directional_filter == "Counter Trend"
        if counter_enabled
            // Calculate z-score and apply counter trend filter
            distance_sum = 0.0
            for i = 0 to lookback_periods - 1
                price_distance = math.abs(close[i] - ma_value[i])
                distance_sum += price_distance
            
            mean_distance = distance_sum / lookback_periods
            
            variance_sum = 0.0
            for i = 0 to lookback_periods - 1
                price_distance = math.abs(close[i] - ma_value[i])
                variance_sum += math.pow(price_distance - mean_distance, 2)
            
            std_dev = math.sqrt(variance_sum / lookback_periods)
            current_distance = math.abs(current_close - ma_value)
            z_score = std_dev > 0 ? current_distance / std_dev : 0
            
            z_score >= counter_zscore
        else
            true
    else
        true


is_buy_signal = buy_signal_buySignal
is_sell_signal = sell_signal_sellSignal


// APPLY MA FILTERS
ma_directional_pass = f_maDirectionalFilter(is_buy_signal, is_sell_signal, close, flexible_ma, ma_directional_filter)
ma_contact_pass = f_maContactFilter(open, close, high, low, flexible_ma, ma_contact_type, enable_ma_contact_filter)
ma_distance_pass = f_maDistanceFilter(close, flexible_ma, ma_directional_filter, is_buy_signal, is_sell_signal, enable_trend_distance_filter, trend_distance_zscore, enable_counter_distance_filter, counter_distance_zscore, 20)


amf_context = f_analyzeAMF(amf_line, amf_signal, is_buy_signal, is_sell_signal, atr14)
alma_context = f_analyzeALMA(alma200, alma2, is_buy_signal, is_sell_signal, atr14)
sr_context = f_analyzeSupportResistance(is_buy_signal, is_sell_signal, atr14, signalHigh, signalLow, signalClose)
swing_context = f_analyzeSwingStructure(is_buy_signal, is_sell_signal, signalHigh, signalLow)
regime_context = f_analyzeMarketRegime(is_buy_signal, is_sell_signal, signalOpen, signalHigh, signalLow, signalClose)


amf_context_normalized = f_normalizeInput(amf_context, normalization_lookback, outlier_clipping, clipping_threshold)
alma_context_normalized = f_normalizeInput(alma_context, normalization_lookback, outlier_clipping, clipping_threshold)
sr_context_normalized = f_normalizeInput(sr_context, normalization_lookback, outlier_clipping, clipping_threshold)
swing_context_normalized = f_normalizeInput(swing_context, normalization_lookback, outlier_clipping, clipping_threshold)
regime_context_normalized = f_normalizeInput(regime_context, normalization_lookback, outlier_clipping, clipping_threshold)


signal_score = (is_buy_signal or is_sell_signal) ?
               f_scoreSignalNormalized(amf_context_normalized, alma_context_normalized,
                                     sr_context_normalized, swing_context_normalized, regime_context_normalized) : 0.5
signal_grade = f_getSignalGrade(signal_score)
score_color = f_getScoreColor(signal_score)


// Check if this specific signal grade should be shown
quality_pass = false
if signal_grade == "A+"
    quality_pass := show_grade_a_plus
else if signal_grade == "A"
    quality_pass := show_grade_a
else if signal_grade == "B"
    quality_pass := show_grade_b
else if signal_grade == "C"
    quality_pass := show_grade_c
else if signal_grade == "D"
    quality_pass := show_grade_d
else if signal_grade == "F"
    quality_pass := show_grade_f
else
    quality_pass := true


// SESSION SIGNAL FILTERING - FIXED LOGIC WITH PROPER OVERLAP BEHAVIOR
session_signal_allowed = false


// For Sydney-Tokyo overlap area
if is_sydney_tokyo_overlap
    // If either individual session is enabled, show signals (overlap setting doesn't matter)
    if enable_sydney_signals or enable_tokyo_signals
        session_signal_allowed := true
    // If both individual sessions are disabled, only show if overlap is enabled
    else if enable_sydney_tokyo_overlap
        session_signal_allowed := true


// For London-New York overlap area  
else if is_london_newyork_overlap
    // If either individual session is enabled, show signals (overlap setting doesn't matter)
    if enable_london_signals or enable_newyork_signals
        session_signal_allowed := true
    // If both individual sessions are disabled, only show if overlap is enabled
    else if enable_london_newyork_overlap
        session_signal_allowed := true


// For non-overlap areas, check individual sessions
else
    if (enable_sydney_signals and is_sydney) or
       (enable_tokyo_signals and is_tokyo) or
       (enable_london_signals and is_london) or
       (enable_newyork_signals and is_newyork)
        session_signal_allowed := true
    else
        session_signal_allowed := false


candleColor = isBullishCandle ? customBuyColor : customSellColor


plotcandle(candleType != "Candlesticks" ? displayOpen : na,
           candleType != "Candlesticks" ? displayHigh : na,
           candleType != "Candlesticks" ? displayLow : na,
           candleType != "Candlesticks" ? displayClose : na,
           title="Alternative Candles",
           color=candleType != "Candlesticks" ? candleColor : na,
           wickcolor=candleType != "Candlesticks" ? candleColor : na,
           bordercolor=candleType != "Candlesticks" ? candleColor : na)


// PLOT MOVING AVERAGES
ma_color = color.new(#2196F3, 0)  // Blue color for primary MA
plot(flexible_ma, title="Primary Moving Average", color=ma_color, linewidth=2)

secondary_ma_color = color.new(#F44336, 0)  // Red color for secondary MA
plot(enable_secondary_ma ? secondary_ma : na, title="Secondary Moving Average", color=secondary_ma_color, linewidth=2)


atr_offset = signalOffset * atr14


show_buy_signal = enable_scalp_helper and buy_signal_buySignal and not buy_atr_stop_active[1] and
                 ma_directional_pass and ma_contact_pass and ma_distance_pass and
                 quality_pass and session_signal_allowed


show_sell_signal = enable_scalp_helper and sell_signal_sellSignal and not sell_atr_stop_active[1] and
                  ma_directional_pass and ma_contact_pass and ma_distance_pass and
                  quality_pass and session_signal_allowed


label_size = signalLabelSize == "tiny" ? size.tiny :
             signalLabelSize == "small" ? size.small :
             signalLabelSize == "large" ? size.large : size.normal


// Remove plotchar and show labels on ALL signals
if showScalpLabels and show_buy_signal
    buy_label_text = signal_grade
    label.new(bar_index, signalLow - atr_offset,
              text=buy_label_text,
              style=label.style_label_up,
              size=label_size,
              color=score_color,
              textcolor=color.white)


if showScalpLabels and show_sell_signal
    sell_label_text = signal_grade
    label.new(bar_index, signalHigh + atr_offset,
              text=sell_label_text,
              style=label.style_label_down,
              size=label_size,
              color=score_color,
              textcolor=color.white)


// CLEAN ALERT CONDITIONS - Only 3 options that respect your indicator settings
alertcondition(show_buy_signal, title="Buy Signal", message=" NeuralMA BUY Signal Detected")
alertcondition(show_sell_signal, title="Sell Signal", message=" NeuralMA SELL Signal Detected")
alertcondition(show_buy_signal or show_sell_signal, title="Any Signal", message=" NeuralMA Signal Detected")